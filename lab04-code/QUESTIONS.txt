                           __________________

                            LAB 04 QUESTIONS
                           __________________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


PROBLEM 1 `capture_stdout.c'
============================

A
~

  Compile and run the program in `capture_stdout.c'. Show its output.


B
~

  The calls `dup()' and `dup2()' are used in this program to manipulate
  file descriptors. Explain the effects of the lines below.
  ,----
  | int stdout_bak = dup(STDOUT_FILENO);
  | dup2(my_pipe[PWRITE], STDOUT_FILENO);
  | ...
  | dup2(stdout_bak, STDOUT_FILENO);
  `----


C
~

  The use of `printf()' normally puts output directly on the
  screen. Explain why the statement
  ,----
  | printf("%d In the pipe, five by five",
  |        getpid());           
  | 
  `----
  does not print to screen as usual.


D
~

  Modify the code so that the `In the pipe...' expression is printed by
  a child process.
  - Add a `fork()' AFTER `dup2()' redirects standard output but before
    the print
  - Add an `if()' to distinguish between parent and child
  - The child should print then exit
  - The parent should restore stdout then read from the pipe
  - Add a `wait()' to guarantee the parent waits for the child to
    complete prior to reading from the pipe
  Paste your completed code below.


NOTE on Large Child Output
~~~~~~~~~~~~~~~~~~~~~~~~~~

  The completed `capture_stdout.c' file should get a child to write into
  a pipe and the parent to read from that pipe. The parent reading is
  currently reading as the lines
  ,----
  |   char buf[2048];
  |   int bytes_read = read(my_pipe[PREAD], buf, 2048);
  `----
  assume that the child output will be no larger than 2048 bytes.  The
  next problem demonstrates a useful allocation pattern which can be
  used to handle large / unknown input sizes.


PROBLEM 2 `append_all.c'
========================

  Examine the code in `append_all.c' which makes use of a number of I/O
  system calls in an interesting pattern.


A
~

  Compile and run the program and experiment with entering data into it.
  Show your session and explain why read() system call always seems to
  read one more character than you type.


B
~

  Describe the initialize size of the array `input' in `append_all.c'
  and how it changes over the run of the program. What standard C
  function is used to initially allocate memory for `input' and what C
  function is used to alter its size? How do these functions work?


C
~

  Restart the `append_all.c' program and type the specific input bleow
  in at the prompts. Show the output produced and describe why it is a
  little funny. How does this relate to the `read()' system call that is
  used in the program's main loop?

  ,----
  | > 123456
  `----


D
~

  In append_all.c, the read call is followed by a commented line:
  ,----
  |     int nread = read(STDIN_FILENO, input+cur_pos, max_read); // perform read()
  |     // int nread = read(STDIN_FILENO, input, max_read);         // error using read()
  `----
  This commented line contains a common error for those new the use of
  the `read()' system call.

  Comment the current read() call and uncomment the line marked as an
  error. Recompile the program and run it entering various
  inputs. Describe why this line is error and relate it to what the
  program now erroneously produces for output.
