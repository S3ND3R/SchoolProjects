                           __________________

                            LAB 06 QUESTIONS
                           __________________


- Name: Warren Weber
- NetID: weber767

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: Binary File Format w/ Read
=====================================

A
~

  Compile all programs in the lab code directory with the provided
  `Makefile'.  Run the command
  ,----
  | ./make_dept_directory cse_depts.dat
  `----
  to create the `cse_depts.dat' binary file. Examine the source code for
  this program the header `department.h'. Explain the format of the
  binary file `cse_depts.dat'.
  - What system calls are used in `make_dept_directory.c' to create this
    file?

    ----------------------------------------------------------------------------
      1. open ()

      2. write()

      3. close()
    ----------------------------------------------------------------------------

  - How is the `sizeof()' operator used to simplify some of the
    computations in `make_dept_directory.c'?

    ----------------------------------------------------------------------------
      'sizeof()' is used to get the amount of bytes used by the type passed to
      it, which in the case of 'make_dept_directory.c' is used to:

      - Correctly set the number of contacts by dividing the bytes used for a
        a contact_t array by the bytes need for a contact_t.

      - Set the offsets to the appropriate location.

      - write the bytes in the array equal to the amount of bytes in the array
    ----------------------------------------------------------------------------

  - What data is in `cse_depts.dat' and how is it ordered?

    ----------------------------------------------------------------------------
     - file_header : a file_header_t struct
     - offsets : an array of dept_offset_t structs
     - cs_dept : an array of contact_t structs
     - ee_dept : an array of contact_t structs
     - it_dept : an array of contact_t structs
    ----------------------------------------------------------------------------

B
~

  Run the `print_department_read' program which takes a binary data file
  and a department code to print.  Show a few examples of running this
  program with the valid command line arguments. Include in your demo
  runs that
  - Use the `cse_depts.dat' with known and unknown department codes

  ,----
  |  weber767@csel-kh4250-29:/home/weber767/csci4061/csci4061-repo/labs/lab06-code $
  |  ./print_department_read cse_depts.dat CS
  |  Dept Name: CS Offset: 104
  |  Dept Name: EE Offset: 2152
  |  Dept Name: IT Offset: 3688
  |
  |  8 Contacts for CS department
  |  Arindam Banerjee <baner029@umn.edu>
  |  Daniel Boley <boley@umn.edu>
  |  Abhishek Chandra <chandra@umn.edu>
  |  David Hung-Chang Du <du@umn.edu>
  |  Maria Gini <gini@umn.edu>
  |  Stephen Guy <sjguy@umn.edu>
  |  Tian He <tianhe@umn.edu>
  |  Mats Heimdahl <heimdahl@umn.edu>
  |
  |
  |  weber767@csel-kh4250-29:/home/weber767/csci4061/csci4061-repo/labs/lab06-code $
  | ./print_department_read cse_depts.dat SD
  |  Dept Name: CS Offset: 104
  |  Dept Name: EE Offset: 2152
  |  Dept Name: IT Offset: 3688
  |  Department code 'SD' not found
  |
  `----
  - Use a file other than `cse_depts.dat'
  ,----
  |
  |  weber767@csel-kh4250-29:/home/weber767/csci4061/csci4061-repo/labs/lab06-code $
  |  ./print_department_read cse_depts.dat.bk EE
  |  Dept Name: CS Offset: 104
  |  Dept Name: EE Offset: 2152
  |  Dept Name: IT Offset: 3688
  |
  |  6 Contacts for EE department
  |  Mehmet Akcakaya <akcakaya@umn.edu>
  |  Massoud Amin <amin@umn.edu>
  |  Kia Bazargan <kia@umn.edu>
  |  Itshak Bergel <ibergel@umn.edu>
  |  Stephen Campbell <scampbell@umn.edu>
  |
  |  weber767@csel-kh4250-29:/home/weber767/csci4061/csci4061-repo/labs/lab06-code $
  |   ./print_department_read department.h EE
  |  'department.h' does not appear to be a binary department directory file
  |
  `----

C
~

  Study the source code for `print_department_read' and describe how it
  initially prints the table of offsets shown below.
  ,----
  | Dept Name: CS Offset: 104
  | Dept Name: EE Offset: 2152
  | Dept Name: IT Offset: 3688
  `----
  What specific sequence of calls leads to this information?

  ------------------------------------------------------------------------------
    If the file passed in from arg[1] is valid, the header is checked for the
    number of departments. Then for the number of dept_offset_t structs, which
    each represent a department, first a temporary dept_offset_t called dept is
    created. Second read is called with the file descriptor of the opened file,
    a pointer to dept, and the size of a dept_offset_t. Finally the printf() call
    outputs dept.dept_code and dept.offset in the string formatted in the style
    shown above.
  ------------------------------------------------------------------------------

D
~

  What system call is used to skip immediately to the location in the
  file where desired contacts are located? What arguments does this
  system call take? Consult the manual entry for this function to find
  out how else it can be used.

  ------------------------------------------------------------------------------
    lseek()
      -arguments : file descriptor (int), offset value (off_t),
                   whence directive (int)
        the whence directs how the offset will be set in the file

      different values for whence can have the offset set to the offset value
      passed, as in 'print_department_read.c', or it can do various things like:
        - current location plus passed offset
        - set at size of file plus passed offset
        - next location greater than or equal to the offset containing data
  ------------------------------------------------------------------------------

PROBLEM 2: mmap() and binary files
==================================

  An alternative to using standard I/O functions is "memory mapped"
  files through the system call `mmap()'. The program
  `print_department_mmap.c' provides the functionality as the previous
  `print_department_read.c' but uses a different mechanism.


(A)
~~~

  Early in `print_department_mmap.c' an `open()' call is used as in the
  previous program but it is followed shortly by a call to `mmap()' in
  the lines
  ,----
  |   char *file_bytes =
  |     mmap(NULL, size, PROT_READ, MAP_SHARED,
  |          fd, 0);
  `----
  Look up reference documentation on `mmap()' and describe some of the
  arguments to it including the `NULL' and `size' arguments. Also
  describe its return value.

  ------------------------------------------------------------------------------
  mmap() arguments:
    - the first argument is a starting address for the mapping, if NULL the
      kernel chooses the address
    - the second argument is the length of the mapping
    - third argument is the memory protection of the argument
        - read, write, execute, not accessible
    - fourth is a flag setting visibility for the mapping
        - MAP_SHARED lets the mapping be seen by child processes
    - fifth is the file descriptor for the opened file
    - last is offset location

    if successful a pointer to the mapping is returned else a MAP_FAILED value
    is returned
  ------------------------------------------------------------------------------

(B)
~~~

  The initial setup of the program uses `mmap()' to assign a pointer to
  variable `char *file_bytes'.  This pointer will refer directly to the
  bytes of the binary file.

  Examine the lines
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // CHECK the file_header_t struct for integrity, size of department array
  |   file_header_t *header = (file_header_t *) file_bytes; // binary header struct is first thing in the file
  `----

  Explain what is happening here: what value will the variable `header'
  get and how is it used in subsequent lines.

  ------------------------------------------------------------------------------
    The character pointer file_bytes that points to the memory mapping is being
    cast to be a file_header_t pointer. After casting it will now be a pointer
    to a file_header_t and can now access the struct members in the file header.
  ------------------------------------------------------------------------------

(C)
~~~

  After finishing with the file header, the next section of the program
  begins with the following.
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // SEARCH the array of department offsets for the department named
  |   // on the command line
  |
  |   dept_offset_t *offsets =           // after file header, array of dept_offset_t structures
  |     (dept_offset_t *) (file_bytes + sizeof(file_header_t));
  |
  `----

  Explain what value the `offsets_arr' variable is assigned and how it
  is used in the remainder of the SEARCH section.

  ------------------------------------------------------------------------------
    offset_arr is assigned a dept_offset_t pointer that was cast from the
    file_bytes pointer at the offset after the file header.

    that pointer is used to access departments directly within a for loop by
  ------------------------------------------------------------------------------

(D)
~~~

  The final phase of the program begins below
  ,----
  |   ////////////////////////////////////////////////////////////////////////////////
  |   // PRINT out all personnel in the specified department
  |   ...
  |   contact_t *dept_contacts = (contact_t *) (file_bytes + offset);
  `----
  Describe what value `dept_contacts' is assigned and how the final
  phase uses it.

  ------------------------------------------------------------------------------
   dept_contacts is a contact_t pointer that points to the offset location that
   was the offset that the contact_t was found to be at within file_header. the
   file_header was a char pointer that needed to be cast to the contact_t * to
   be able to access that structs members.

   now the contacts can be looped through and the contacts name and email can
   be printed out.
  ------------------------------------------------------------------------------ 
