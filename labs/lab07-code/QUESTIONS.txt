                           __________________

                            LAB 07 QUESTIONS
                           __________________


- Name: Warren Weber
- NetID: weber767

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: Virtual Memory and pmap
==================================

(A)
~~~

  Examine the source code for the provided `memory_parts.c'
  program. Identify what region of program memory you expect the
  following variables to be allocated into:
  - global_arr[]
  - local_arr[]
  - malloc_arr

  ------------------------------------------------------------------------------
    -'global_arr[]' is declared outside of main so it should be a global
    variable, therefore it should be located in the Data section of memory

    - 'local_arr[]' is declared locally within the main function, therefore it
    should be located in the stack

    - 'malloc_arr a function that allocates new memory, therefore it will be
    located in the heap
  ------------------------------------------------------------------------------

(B)
~~~

  Compile the `memory_parts' using the provided Makefile.
  ,----
  | > make memory_parts
  `----
  Run the program and note that it prints several pieces of information
  - The addresses of several of the variables allocated
  - Its Process ID (PID) which is a unique number used to identify the
    running program. This is an integer.
  For example, the output might be
  ,----
  | > ./memory-parts
  | 0x55dc6442c98a : main()
  | 0x55dc6462d0c0 : global_arr
  | 0x7ffc7f3e0310 : local_arr
  | 0x55dc652ad260 : malloc_arr
  | 0x7f53c5280000 : mmap'd file
  | my pid is 11160
  | press any key to continue
  `----
  so the programs PID is 11160

  The program will also stop at this point until a key is pressed. DO
  NOT PRESS A KEY YET.

  Open another terminal and type the following command in that new
  terminal.
  ,----
  | > pmap THE-PID-NUMBER-THAT-WAS-PRINTED-EARLY
  `----
  Paste the output of pmap below.

  ,----
  |  14618:   ./memory_parts
  |  000055a701954000      4K r-x-- memory_parts
  |  000055a701b55000      4K r---- memory_parts
  |  000055a701b56000      4K rw--- memory_parts
  |  000055a701b57000      4K rw---   [ anon ]
  |  000055a7028dd000    132K rw---   [ anon ]
  |  00007f6d89eaa000   1948K r-x-- libc-2.27.so
  |  00007f6d8a091000   2048K ----- libc-2.27.so
  |  00007f6d8a291000     16K r---- libc-2.27.so
  |  00007f6d8a295000      8K rw--- libc-2.27.so
  |  00007f6d8a297000     16K rw---   [ anon ]
  |  00007f6d8a29b000    156K r-x-- ld-2.27.so
  |  00007f6d8a470000      8K rw---   [ anon ]
  |  00007f6d8a4c2000      4K r---- ld-2.27.so
  |  00007f6d8a4c3000      4K rw--- ld-2.27.so
  |  00007f6d8a4c4000      4K rw---   [ anon ]
  |  00007ffe822e9000    136K rw---   [ stack ]
  |  00007ffe8234c000     12K r----   [ anon ]
  |  00007ffe8234f000      8K r-x--   [ anon ]
  |  ffffffffff600000      4K r-x--   [ anon ]
  |   total             4520K
  `----

(C)
~~~

  pmap prints out the virtual address space table for the program. The
  leftmost column is a virtual address mapped by the OS for the program
  to some physical location.  The next column is the size of the area of
  memory associated with that starting address. The 3rd column contains
  permissions of the program has for the memory area: r for read, w for
  read, x for execute. The final column is contains any identifying
  information about the memory area that pmap can discern.

  Compare the addresses of variables and functions from the paused
  program to the output. Try to determine the virtual address space in
  which each variable resides and what region of program memory that
  virtual address must belong to (stack, heap, globals, text).  In some
  cases, the identifying information provided by pmap may make this
  obvious.

  ------------------------------------------------------------------------------
    0x55a701b56040 : global_arr
    0x55a701b56000 < 0x55a701b56040 < 0x55a701b57000
    - the virtual memory address looks to be in the lower part of the memory
      allocated for the process, so it should be the data section since the
      only part of memory that is lower is reserved for compiled code.

    0x7ffe82308e30 : local_arr
    0x7ffe822e9000 < 0x7ffe82308e30 < 0x7ffe8234c000
    - the virtual memory address is greater than the first part of memory set
    aside for the stack and it is less than the next section of memory, so it
    should be a stack location.

    0x55a7028dd260 : malloc_arr
    0x55a7028dd000 < 0x55a7028dd260 < 0x7f6d89eaa000
    - the virtual memory address is located in a section of memory lower than
    the first section of shared memory, but is higher than the section that held
    data. This section should be within the heap section of memory.
  ------------------------------------------------------------------------------

(D)
~~~

  The minimum size of any virtual area of memory appears to be 4K. Why
  is this the case?

  ------------------------------------------------------------------------------
    The default size for pages on most UNIX systems is 4k, and since memory is
  segmented into page size hunks the minimum size of any virtual area is the
  size of a page.
  ------------------------------------------------------------------------------


(E)
~~~

  Notice that in addition to the "normal" variables that are mapped,
  there is also an entry for the mmap()'d file 'gettysburg.txt' in the
  virtual address table.  The mmap() function is explored in the next
  problem but note its calling sequence which involves use of a couple
  system calls:
  1. `open()' which is a low level file opening call which returns a
     numeric file descriptor.
  2. `fstat()' which obtains information such as size for an open file
     based on its numeric file descriptor. The `stat()' system call was
     explored earlier in the class and does the same thing provided the
     name of a file.

PROBLEM 2 `birth_death.c'
=========================

A
~

  Compile `circle_of_life.c' to the program `circle_of_life' and run
  it. Examine the results and feel free to terminate execution
  early. Examine the source code if desired though it is merely a
  print/sleep loop.

  Compile `birth_death.c' to the program `birth_death'. This program is
  invoked with two arguments, another program name and a "lifetime"
  which is an integer number of seconds. Run it like
  ,----
  | $> ./birth_death ./circle_of_life 4
  `----
  and show the output below.

  ,----
  |  Sithi uhm ingonyama
  |  Nants ingonyama bagithi baba
  |  Sithi uhm ingonyama
  |  kill result: 0
  |  child process 3973 terminated with signal 2
  `----

B
~

  Examine the source code for `birth_death.c' and determine the system
  call the parent program (`birth_death') uses to send signals to the
  child program. Paste this line below and explain which signal is being
  sent.

  ------------------------------------------------------------------------------

  ,----
  |  int result = kill(pid,SIGINT);
  `----

  The interrupt signal is being sent to the pid process, because the second
  argument passed is the SIGINT signal.
  ------------------------------------------------------------------------------

C
~

  `birth_death.c' waits for a child to finish then outputs what signal
  caused it to be terminated if that was the cause of death. Paste the
  lines of code which determine if a child was terminated due to a
  signal below and mention the macros used for this purpose.

  ------------------------------------------------------------------------------

  ,----
  |  if(WIFSIGNALED(status)){
  |    printf("child process %d terminated with signal %d\n",
  |           pid,WTERMSIG(status));
  |  }
  `----

  - WIFSIGNALED(status)
      returns true if a child process was terminated by a signal
  - WTERMSIG(status)
      returns the signal that was used to terminate the child process
  ------------------------------------------------------------------------------

D
~

  Compile the program `no_interruptions.c' and run it with
  `birth_death'. Show your results below.

  Note that you may need to send signals to `no_interruptions' to
  forcibly end it. The `pkill' command is useful for this as in
  ,----
  | pkill no_inter        # send TERM signal to proc name matching "no_inter"
  | pkill -KILL no_inter  # send KILL signal to proc name matching "no_inter"
  `----

  ,----
  | ./birth_death ./no_inter 4
  |  Ma-na na-na!
  |
  |  No SIGINT-erruptions allowed.
  |  kill result: 0
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  Ma-na na-na!
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  Ma-na na-na!
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  Ma-na na-na!
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  Ma-na na-na!
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  kill result: 0
  |
  |  No SIGINT-erruptions allowed.
  |  child process 5121 terminated with signal 9
  `----

E
~

  Examine the `no_interruptions.c' code and describe how it is able to
  avoid being killed when receiving the interrupt and TERM signals. Show
  the lines of code used to accomplish this signal handling.

  ------------------------------------------------------------------------------
    'no_interruptions.c' is able to avoid being killed by altering the actions
  taken when an interrupt signal or termination signal are sent to the process,
  by use of the 'signal()' call. The 'signal()' call blocks the normal signal
  action and then calls the passed handler function, with the blocked signal's
  number.

  signal call:
  ,----
  |  signal(SIGINT, handle_SIGINT);
  |  signal(SIGTERM, handle_SIGTERM);
  `----

  handlers:
  ,----
  |  void handle_SIGINT(int sig_num) {
  |    signal(SIGINT, handle_SIGINT);
  |    printf("\nNo SIGINT-erruptions allowed.\n");
  |    fflush(stdout);
  |  }
  |
  |  void handle_SIGTERM(int sig_num) {
  |    signal(SIGTERM, handle_SIGTERM);
  |    printf("\nTry to SIGTERM me? Piss off!\n");
  |    fflush(stdout);
  |  }
  `----
  ------------------------------------------------------------------------------
