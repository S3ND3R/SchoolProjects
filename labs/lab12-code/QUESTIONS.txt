                           __________________

                            LAB 12 QUESTIONS
                           __________________


- Name: Warren Weber
- NetID: weber767

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


PROBLEM 1: Spell Checking Busily
================================

A
~

  Examine the file `check_spelling_busy.c' which performs the simple
  task of spell checking words that are typed into the terminal using
  pthreads.  Compile this program with the provided `Makefile' and run
  it showing your results below.

  ,----
    Enter words to check spelling, Ctrl-d to end input
    hat
    'hat' ok
    that
    'that' ok
    ho
    'ho' ok
    store
    'store' ok
    turtle
    'turtle' ok
    zzz
    'zzz' INCORRECT
    ZZZ
    'ZZZ' INCORRECT
    Zzz
    'Zzz' ok
    AAA
    'AAA' ok
    Aachen
    'Aachen' ok
    nirvana
    'nirvana' ok
    b
    'b' ok
  `----

B
~

  Examine the source code for `check_spelling_busy.c' and describe the
  basic architecture of how input is accepted and spell checking is
  done.  Describe what data structure is used to coordinate reading and
  checking the spelling of words. How is access to this data structure
  controlled so that the threads to not corrupt it.

  --------------------------------------------------------------------
    - pending words are stored in a bounded circular queue.
    - mutex is used to lock the queue whenever it is being accessed by
      either 'read_words()' or 'check_words()'
  --------------------------------------------------------------------


C
~

  Identify what conditions are required for each of the thread types to
  make progress: what must be true about the shared data structure in
  order for them to proceed? How are these conditions checked?

  --------------------------------------------------------------------
    'read_thread': There must be space in the queue to read in a word,
                   which is checked in a while loop that is able to
                   break when the condition is met.
    'check_thread': The queue must not be empty or quit_now has been
                    set to one. If quit_now is set and the queue is
                    empty the thread breaks out and ends.
  --------------------------------------------------------------------


D
~

  Time the following run of `check_spelling_busy'.
  1. Start the program via `time ./check_spelling_busy'
  2. Type the word 'hello' and press enter
  3. Type Ctrl-d to end input

  Report your timing for this run below which should appear somewhat
  strange.  Attempt to explain this strange behavior based on your
  observations of thread behavior above.

  --------------------------------------------------------------------
  ,----
    real	0m3.143s
    user	0m3.140s
    sys	0m0.000s
  `----

  The locks prevent both functions from running in parallel, which
  explains why the real is the same as the user.
  --------------------------------------------------------------------


PROBLEM 2: Spell Checking Efficiently
=====================================

A
~

  Examine the code for `check_spelling_condvar.c' which introduces
  Pthread Condition Variables.  First, run the same experiment and
  compare the timing to this new version:

  1. Start the program via `time ./check_spelling_condvar'
  2. Type the word 'hello' and press enter
  3. Type Ctrl-d to end input

  --------------------------------------------------------------------
  busy version:
  ,----
    real	0m3.143s
    user	0m3.140s
    sys	0m0.000s
  `----

  condition variable version:
  ,----
    real	0m10.929s
    user	0m0.020s
    sys	0m0.001s
  `----

  The condition variable version is able to reduce the user time
  compared to the busy version.
  --------------------------------------------------------------------


B
~

  Much of the code between `check_spelling_busy' and
  `check_spelling_condvar' is identical. An important difference is in
  the portion where threads determine whether the conditions to proceed
  have been met.

  Examine closely the sections of code that `check_spelling_condvar.c'
  use to determine when the reader thread can add something to the queue
  and when checker thread has a word to check. Describe these
  changes. Research the new functions that are used and briefly describe
  them.

  --------------------------------------------------------------------
   The change is in the use of condition Variables
   ,----

     pthread_cond_wait(&word_queue_not_full, &word_queue_lock);
     //...
     pthread_cond_wait(&word_queue_not_empty, &word_queue_lock);

   `----
    pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex)
      - takes a pointer to a condition
      - takes a pointer to a mutex
      The call causes the thread to wait until a signal is sent to
      the condition that was passed as a pointer. Upon calling the
      mutex will be unlocked and once the condition recieves the
      signal it will attempt to re-lock the mutex, blocking if another
      thread has already locked the mutex.

      ,----

       pthread_cond_broadcast(&word_queue_not_empty);
       //...
       pthread_cond_broadcast(&word_queue_not_full);

      `----
      int pthread_cond_broadcast(pthread_cond_t *cond)
      - takes a pointer to a condition
      The call will unblock all threads that have been blocked on the
      passed condition variable.
  --------------------------------------------------------------------


C
~

  What function call do the two threads use to communicate that the
  'condition' of the queue has changed? What affect does this function
  have on the other thread?

  --------------------------------------------------------------------
  int pthread_cond_broadcast(pthread_cond_t *cond)
  - takes a pointer to a condition
  The call will unblock all threads that have been blocked on the
  passed condition variable.

  The thread that is blocked by the wait condition will stop
  blocking and try to lock the mutex that was passed to it once again.
  --------------------------------------------------------------------


D
~

  This spell checking code is an instance of the classic
  producer/consumer coordination problem where two different types of
  threads/processes exist: one producing data (the reader in this case)
  and the other consuming it (the spell checker in this case).  When
  these threads can only proceed under different conditions, condition
  variables make their coordination more efficient than would be
  possible based on locks (mutexes) alone.

  Benchmark the efficiency of spell-checking 100 words using the
  following commands to compare the two variations. Show your code below
  and describe the timing differences.

  ,----
  | > time tail -100 english-dict.txt | ./check_spelling_busy > /dev/null
  | ...
  |
  | > time tail -100 english-dict.txt | ./check_spelling_condvar > /dev/null
  | ...
  `----

  --------------------------------------------------------------------
  ,----
    > time tail -100 english-dict.txt | ./check_spelling_busy > /dev/null
    real	0m0.844s
    user	0m1.623s
    sys	  0m0.012s
    > time tail -100 english-dict.txt | ./check_spelling_condvar > /dev/null
    real	0m0.839s
    user	0m0.825s
    sys	  0m0.014s
  `----

  There is no noticeable difference in the real time for the two
  versions, but in the user time the busy version takes almost twice
  as much CPU time. 
  --------------------------------------------------------------------
