                           __________________

                            LAB 13 QUESTIONS
                           __________________


- Name: Warren Weber
- NetID: weber767

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


Problem 1 `http_get.c'
======================

  Examine the source code for `http_get.c' and use it to contact a few
  hosts and files such as those shown at the top of the source.  Answer
  the following questions.


A
~

  - What is the full name of the that protocol is being employed?
  - Which port does the server listen on in this protocol?
  ------------------------------------------------------------------------
    - HyperText Transfer Protocol
    - port 80
  ------------------------------------------------------------------------


B
~

  Describe which system calls are used to find an internet address,
  create a socket, and connect the socket to the found address.
  ------------------------------------------------------------------------
    - getaddrinfo() turns a host name into a usable address.
    - socket() creates a socket connected to an internet address
    - connect() connects socket to foreign address
  ------------------------------------------------------------------------

C
~

  In this protocol, which entity, SERVER or CLIENT, sends data first?
  (Though you don't have access to a server code, this should be obvious
  from the structure of the client code).
  ------------------------------------------------------------------------
    Client sends the data first then the server responds to its request.
  ------------------------------------------------------------------------

D
~

  Does the protocol work in plain text (human readable) or in binary
  format (harder for humans to read directly).  Show examples/evidence
  to support your answer.
  ------------------------------------------------------------------------
   ,-----
      REQUEST
    -------
    GET /guide/bgnet/examples/client.c HTTP/1.0
    Host: beej.us
    Connection: close
   `-----
   ,-----
    -------
    RESPONSE
    -------
    HTTP/1.1 200 OK
    Date: Fri, 03 May 2019 19:10:27 GMT
    Server: Apache
    Last-Modified: Mon, 18 Dec 2017 16:36:49 GMT
    ETag: "792-5609ff4f8f58f"
    Accept-Ranges: bytes
    Content-Length: 1938
    Connection: close
    Content-Type: text/x-c

    /*
    ** client.c -- a stream socket client demo
    */

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <errno.h>
    #include <string.h>
    #include <netdb.h>
    #include <sys/types.h>
    #include <netinet/in.h>
    #include <sys/socket.h>

    #include <arpa/inet.h>

    #define PORT "3490" // the port client will be connecting to

    #define MAXDATASIZE 100 // max number of bytes we can get at once

    // get sockaddr, IPv4 or IPv6:
    void *get_in_addr(struct sockaddr *sa)
    {
     if (sa->sa_family == AF_INET) {
       return &(((struct sockaddr_in*)sa)->sin_addr);
     }

     return &(((struct sockaddr_in6*)sa)->sin6_addr);
    }

    int main(int argc, char *argv[])
    {
     int sockfd, numbytes;
     char buf[MAXDATASIZE];
     struct addrinfo hints, *servinfo, *p;
     int rv;
     char s[INET6_ADDRSTRLEN];

     if (argc != 2) {
         fprintf(stderr,"usage: client hostname\n");
         exit(1);
     }

     memset(&hints, 0, sizeof hints);
     hints.ai_family = AF_UNSPEC;
     hints.ai_socktype = SOCK_STREAM;

     if ((rv = getaddrinfo(argv[1], PORT, &hints, &servinfo)) != 0) {
       fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
       return 1;
     }

     // loop through all the results and connect to the first we can
     for(p = servinfo; p != NULL; p = p->ai_next) {
       if ((sockfd = socket(p->ai_family, p->ai_socktype,
           p->ai_protocol)) == -1) {
         perror("client: socket");
         continue;
       }

       if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
         perror("client: connect");
         close(sockfd);
         continue;
       }

       break;
     }

     if (p == NULL) {
       fprintf(stderr, "client: failed to connect\n");
       return 2;
     }

     inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr),
         s, sizeof s);
     printf("client: connecting to %s\n", s);

     freeaddrinfo(servinfo); // all done with this structure

     if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
         perror("recv");
         exit(1);
     }

     buf[numbytes] = '\0';

     printf("client: received '%s'\n",buf);

     close(sockfd);

     return 0;
    }
   `-----
   - yes it is in plain text
  ------------------------------------------------------------------------

E
~

  Many protocols use /headers/ which are meant to convey information
  between the communication programs about the state of the
  communication but are NOT data that a program user would be interested
  in.  Show a few headers which appear in communication and describe
  what you infer their meaning to be.
  ------------------------------------------------------------------------
  ,----
   GET /guide/bgnet/examples/client.c HTTP/1.0
  `----
   -Shows requested file and protocol
   ,----
    Server: Apache
   `----
   -Web server
  ------------------------------------------------------------------------

F
~

  Attempting to hunt down the actual homepage for the UMN via
  ,----
  | ./http_get twin-cities.umn.edu /
  `----
  will produce an interesting conundrum: the address to be contacted to
  retrieve the file uses a DIFFERENT PROTOCOL.

  Identify this other protocol, the port its servers use, and why it
  would be much more complex to write a client to use it.
  ------------------------------------------------------------------------
  HTTPS: port 443
  - makes use of encryption
  ------------------------------------------------------------------------


Problem 2 `http_get_ssl.c'
==========================

  Examine the source code for `http_get_ssl.c' and use it to contact
  some of the same hosts that you did with `http_get.c'.  Answer the
  following questions.

A
~

  Determine what additional measures `http_get_ssl.c' employs to use a
  secure protocol for communication with a server.  Show the code block
  that accomplishes this (though no explanation is required).
  ------------------------------------------------------------------------
  ////////////////////////////////////////////////////////////////////////////////
  // Initialize and set up a secure connection with the SSL library
  OpenSSL_add_all_algorithms();
  SSL_library_init();
  const SSL_METHOD *method = SSLv23_client_method();
  SSL_CTX *ctx = SSL_CTX_new(method);
  SSL *ssl_connection = SSL_new(ctx);
  assert(ssl_connection != NULL);
  SSL_set_fd(ssl_connection, sockfd);
  SSL_connect(ssl_connection);
  // Setup of SSL is complete. The variable 'ssl_connection' is used
  // like a file descriptor with SSL_write() / SSL_read(). The data
  // transmitted will be automatically encrypted/decrypted.
  ////////////////////////////////////////////////////////////////////////////////
  ------------------------------------------------------------------------

B
~

  Aside from the code block that is added above to enable secure
  communication, are there any other large changes between `http_get.c'
  and `http_get_ssl.c' to implement the secure communication version?
  ------------------------------------------------------------------------
  Not really
  - sockets are set up and connected the same way
  - the only difference is it needs to use SSL_write() and
    SSL_read()
  ------------------------------------------------------------------------
